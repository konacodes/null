-- nullc/main.null
-- Self-hosted null compiler - minimal AST-driven version
-- Note: Uses hardcoded name "main" due to compiler bug with
-- loading names inside while loops

@use "std/io.null"
@use "std/mem.null"
@use "std/string.null"
@use "std/file.null"
@use "nullc/parser.null"
@use "nullc/codegen.null"

-- Get return value from a return statement
-- Returns the integer literal value (assumes simple case)
fn get_return_value(ret_node :: ptr<u8>) -> i64 do
    -- init (return value) is at offset 152
    let init :: ptr<u8> = load_ptr(ptr_add(ret_node, 152))
    let null_ptr :: ptr<u8> = 0
    if init == null_ptr do
        ret 0
    end
    -- Get int_value from the literal (offset 24)
    let val :: i64 = load_i64(ptr_add(init, 24))
    ret val
end

-- Get function name from a call expression
fn get_call_name(call_node :: ptr<u8>) -> ptr<u8> do
    -- callee is at offset 96, it should be an identifier node
    let callee :: ptr<u8> = load_ptr(ptr_add(call_node, 96))
    -- identifier name is at offset 56
    let name :: ptr<u8> = load_ptr(ptr_add(callee, 56))
    ret name
end

-- Check if a call has string literal argument
fn call_has_string_arg(call_node :: ptr<u8>) -> bool do
    -- args.data at offset 104, args.count at offset 112
    let args_count :: i64 = load_i64(ptr_add(call_node, 112))
    if args_count > 0 do
        let args_data :: ptr<u8> = load_ptr(ptr_add(call_node, 104))
        let first_arg :: ptr<u8> = load_ptr(args_data)
        let arg_kind :: i64 = load_i64(first_arg)
        -- NODE_LITERAL_STRING = 18
        if arg_kind == 18 do
            ret true
        end
    end
    ret false
end

-- Simple symbol table for variable tracking
-- Stored in Codegen struct (symtab_entries, symtab_count)
-- Each entry: name (ptr<u8>, 8 bytes) + temp (i64, 8 bytes) = 16 bytes

fn symtab_init(cg :: Codegen) -> Codegen do
    let size :: u64 = 1024  -- 64 entries * 16 bytes each
    cg.symtab_entries = alloc(size)
    mem_zero(cg.symtab_entries, size)
    cg.symtab_count = 0
    ret cg
end

fn symtab_add(cg :: Codegen, name :: ptr<u8>, temp :: i64) -> Codegen do
    -- Store at offset count * 16
    let offset :: i64 = cg.symtab_count * 16
    let entry_ptr :: ptr<u8> = ptr_add(cg.symtab_entries, offset)
    store_ptr(entry_ptr, name)
    store_i64(ptr_add(entry_ptr, 8), temp)
    cg.symtab_count = cg.symtab_count + 1
    ret cg
end

-- Lookup returns -1 if not found, else temp number
fn symtab_lookup(cg :: Codegen, name :: ptr<u8>) -> i64 do
    let i :: i64 = 0
    while i < cg.symtab_count do
        let offset :: i64 = i * 16
        let entry_ptr :: ptr<u8> = ptr_add(cg.symtab_entries, offset)
        let entry_name :: ptr<u8> = load_ptr(entry_ptr)
        -- Use str_eq from std/string.null
        if str_eq(entry_name, name) do
            let temp :: i64 = load_i64(ptr_add(entry_ptr, 8))
            ret temp
        end
        i = i + 1
    end
    ret 0 - 1  -- -1 means not found
end

-- Emit expression and return result temp
struct ExprResult do
    cg :: Codegen
    temp :: i64
end

-- Check if expression is an identifier (NODE_IDENT = 20)
fn is_ident(expr :: ptr<u8>) -> bool do
    let kind :: i64 = load_i64(expr)
    ret kind == 20
end

-- Check if expression is a literal int (NODE_LITERAL_INT = 16)
fn is_literal_int(expr :: ptr<u8>) -> bool do
    let kind :: i64 = load_i64(expr)
    ret kind == 16
end

fn emit_expr_val(cg :: Codegen, expr :: ptr<u8>) -> ExprResult do
    let kind :: i64 = load_i64(expr)
    let result_temp :: i64 = next_temp(cg)

    -- NODE_LITERAL_INT = 16
    if kind == 16 do
        let val :: i64 = load_i64(ptr_add(expr, 24))
        -- Return negative temp to indicate this is an immediate value
        -- We use a special marker: temp = val + 1000000 to distinguish from real temps
        -- Actually, simpler: store the value directly, emit_binary will handle it
        let res :: ExprResult = ExprResult { cg = cg, temp = val }
        ret res
    end

    -- NODE_IDENT = 20 - load variable from symtab
    if kind == 20 do
        let name :: ptr<u8> = load_ptr(ptr_add(expr, 56))
        let var_temp :: i64 = symtab_lookup(cg, name)
        if var_temp >= 0 do
            -- Emit load from the variable's alloca
            cg = inc_temp(cg)
            cg = emit_load(cg, result_temp, "i64", var_temp)
            let res :: ExprResult = ExprResult { cg = cg, temp = result_temp }
            ret res
        end
        -- Variable not found - error case, return 0
        let res :: ExprResult = ExprResult { cg = cg, temp = 0 }
        ret res
    end

    -- NODE_BINARY = 21
    if kind == 21 do
        -- Get op (offset 64), left (offset 72), right (offset 80)
        let op :: i64 = load_i64(ptr_add(expr, 64))
        let left :: ptr<u8> = load_ptr(ptr_add(expr, 72))
        let right :: ptr<u8> = load_ptr(ptr_add(expr, 80))

        -- Evaluate left operand
        let left_res :: ExprResult = emit_expr_val(cg, left)
        cg = left_res.cg

        -- Check if right is literal int for optimization
        if is_literal_int(right) do
            let right_val :: i64 = load_i64(ptr_add(right, 24))
            let res_temp :: i64 = next_temp(cg)
            cg = inc_temp(cg)

            -- Arithmetic operations: BIN_ADD=0, BIN_SUB=1, BIN_MUL=2, BIN_DIV=3, BIN_MOD=4
            if op == 0 do
                cg = emit_binop_temp_imm(cg, res_temp, "add", "i64", left_res.temp, right_val)
            end
            if op == 1 do
                cg = emit_binop_temp_imm(cg, res_temp, "sub", "i64", left_res.temp, right_val)
            end
            if op == 2 do
                cg = emit_binop_temp_imm(cg, res_temp, "mul", "i64", left_res.temp, right_val)
            end
            if op == 3 do
                cg = emit_binop_temp_imm(cg, res_temp, "sdiv", "i64", left_res.temp, right_val)
            end
            if op == 4 do
                cg = emit_binop_temp_imm(cg, res_temp, "srem", "i64", left_res.temp, right_val)
            end
            -- Comparison operations: BIN_EQ=5, BIN_NE=6, BIN_LT=7, BIN_LE=8, BIN_GT=9, BIN_GE=10
            if op == 5 do
                cg = emit_icmp_temp_imm(cg, res_temp, "eq", "i64", left_res.temp, right_val)
            end
            if op == 6 do
                cg = emit_icmp_temp_imm(cg, res_temp, "ne", "i64", left_res.temp, right_val)
            end
            if op == 7 do
                cg = emit_icmp_temp_imm(cg, res_temp, "slt", "i64", left_res.temp, right_val)
            end
            if op == 8 do
                cg = emit_icmp_temp_imm(cg, res_temp, "sle", "i64", left_res.temp, right_val)
            end
            if op == 9 do
                cg = emit_icmp_temp_imm(cg, res_temp, "sgt", "i64", left_res.temp, right_val)
            end
            if op == 10 do
                cg = emit_icmp_temp_imm(cg, res_temp, "sge", "i64", left_res.temp, right_val)
            end
            let res :: ExprResult = ExprResult { cg = cg, temp = res_temp }
            ret res
        end

        -- General case: evaluate right operand
        let right_res :: ExprResult = emit_expr_val(cg, right)
        cg = right_res.cg
        let res_temp :: i64 = next_temp(cg)
        cg = inc_temp(cg)

        -- Arithmetic operations with two temps
        if op == 0 do
            cg = emit_binop(cg, res_temp, "add", "i64", left_res.temp, right_res.temp)
        end
        if op == 1 do
            cg = emit_binop(cg, res_temp, "sub", "i64", left_res.temp, right_res.temp)
        end
        if op == 2 do
            cg = emit_binop(cg, res_temp, "mul", "i64", left_res.temp, right_res.temp)
        end
        if op == 3 do
            cg = emit_binop(cg, res_temp, "sdiv", "i64", left_res.temp, right_res.temp)
        end
        if op == 4 do
            cg = emit_binop(cg, res_temp, "srem", "i64", left_res.temp, right_res.temp)
        end
        -- Comparison with two temps
        if op == 5 do
            cg = emit_icmp(cg, res_temp, "eq", "i64", left_res.temp, right_res.temp)
        end
        if op == 6 do
            cg = emit_icmp(cg, res_temp, "ne", "i64", left_res.temp, right_res.temp)
        end
        if op == 7 do
            cg = emit_icmp(cg, res_temp, "slt", "i64", left_res.temp, right_res.temp)
        end
        if op == 8 do
            cg = emit_icmp(cg, res_temp, "sle", "i64", left_res.temp, right_res.temp)
        end
        if op == 9 do
            cg = emit_icmp(cg, res_temp, "sgt", "i64", left_res.temp, right_res.temp)
        end
        if op == 10 do
            cg = emit_icmp(cg, res_temp, "sge", "i64", left_res.temp, right_res.temp)
        end
        let res :: ExprResult = ExprResult { cg = cg, temp = res_temp }
        ret res
    end

    -- NODE_CALL = 23
    if kind == 23 do
        let name :: ptr<u8> = get_call_name(expr)
        if call_has_string_arg(expr) do
            cg = emit_call_with_str(cg, "puts", 0)
        else do
            -- Get call arguments (data at 104, count at 112)
            let args_data :: ptr<u8> = load_ptr(ptr_add(expr, 104))
            let args_count :: i64 = load_i64(ptr_add(expr, 112))

            if args_count == 2 do
                -- Two-argument call
                let arg0 :: ptr<u8> = load_ptr(args_data)
                let arg1 :: ptr<u8> = load_ptr(ptr_add(args_data, 8))
                let arg0_kind :: i64 = load_i64(arg0)
                let arg1_kind :: i64 = load_i64(arg1)

                -- Check if both are literals
                if arg0_kind == 16 do
                    if arg1_kind == 16 do
                        let val0 :: i64 = load_i64(ptr_add(arg0, 24))
                        let val1 :: i64 = load_i64(ptr_add(arg1, 24))
                        cg = emit_call_i64_2imm(cg, name, val0, val1)
                    else do
                        -- First is literal, second is expression
                        let val0 :: i64 = load_i64(ptr_add(arg0, 24))
                        let arg1_res :: ExprResult = emit_expr_val(cg, arg1)
                        cg = arg1_res.cg
                        -- Need mixed call (imm, temp) - for now, load val0 to temp
                        cg = emit_call_i64_2imm(cg, name, val0, arg1_res.temp)
                    end
                else do
                    -- First is expression
                    let arg0_res :: ExprResult = emit_expr_val(cg, arg0)
                    cg = arg0_res.cg
                    if arg1_kind == 16 do
                        let val1 :: i64 = load_i64(ptr_add(arg1, 24))
                        cg = emit_call_i64_2arg(cg, name, arg0_res.temp, val1)
                    else do
                        let arg1_res :: ExprResult = emit_expr_val(cg, arg1)
                        cg = arg1_res.cg
                        cg = emit_call_i64_2arg(cg, name, arg0_res.temp, arg1_res.temp)
                    end
                end

                let call_result :: i64 = get_last_temp(cg)
                let res :: ExprResult = ExprResult { cg = cg, temp = call_result }
                ret res
            end
            if args_count == 1 do
                -- Single-argument call
                let arg0 :: ptr<u8> = load_ptr(args_data)
                let arg0_kind :: i64 = load_i64(arg0)

                -- Check if arg is a literal int (NODE_LITERAL_INT = 16)
                if arg0_kind == 16 do
                    let arg_val :: i64 = load_i64(ptr_add(arg0, 24))
                    cg = emit_call_i64_1imm(cg, name, arg_val)
                else do
                    -- Evaluate argument expression
                    let arg_res :: ExprResult = emit_expr_val(cg, arg0)
                    cg = arg_res.cg
                    cg = emit_call_i64_1arg(cg, name, arg_res.temp)
                end

                let call_result :: i64 = get_last_temp(cg)
                let res :: ExprResult = ExprResult { cg = cg, temp = call_result }
                ret res
            end
            if args_count == 0 do
                cg = emit_call_void(cg, name)
            end
        end
    end

    -- NODE_ASSIGN = 26 - variable assignment
    if kind == 26 do
        -- left (offset 72) should be an identifier, right (offset 80) is the value
        let left :: ptr<u8> = load_ptr(ptr_add(expr, 72))
        let right :: ptr<u8> = load_ptr(ptr_add(expr, 80))

        -- Get variable name from left (which should be NODE_IDENT with name at offset 56)
        let var_name :: ptr<u8> = load_ptr(ptr_add(left, 56))
        let var_temp :: i64 = symtab_lookup(cg, var_name)

        -- Check if right is a literal int - use immediate store
        let right_kind :: i64 = load_i64(right)
        if right_kind == 16 do
            -- NODE_LITERAL_INT - use store immediate
            let val :: i64 = load_i64(ptr_add(right, 24))
            cg = emit_store_imm(cg, "i64", val, var_temp)
            let res :: ExprResult = ExprResult { cg = cg, temp = val }
            ret res
        end

        -- General case: Evaluate right side and store
        let val_res :: ExprResult = emit_expr_val(cg, right)
        cg = val_res.cg
        cg = emit_store(cg, "i64", val_res.temp, var_temp)

        let res :: ExprResult = ExprResult { cg = cg, temp = val_res.temp }
        ret res
    end

    let res :: ExprResult = ExprResult { cg = cg, temp = result_temp }
    ret res
end

-- Emit an expression (handles calls)
fn emit_expr(cg :: Codegen, expr :: ptr<u8>) -> Codegen do
    let res :: ExprResult = emit_expr_val(cg, expr)
    ret res.cg
end

-- Get next temp number and increment
fn next_temp(cg :: Codegen) -> i64 do
    let t :: i64 = cg.temp_counter
    ret t
end

fn inc_temp(cg :: Codegen) -> Codegen do
    cg.temp_counter = cg.temp_counter + 1
    ret cg
end

-- Get next label number and increment
fn next_label(cg :: Codegen) -> i64 do
    let l :: i64 = cg.label_counter
    ret l
end

fn inc_label(cg :: Codegen) -> Codegen do
    cg.label_counter = cg.label_counter + 1
    ret cg
end

-- Emit a variable declaration
fn emit_var_decl(cg :: Codegen, stmt :: ptr<u8>) -> Codegen do
    -- Get variable name from node (offset 56)
    let name :: ptr<u8> = load_ptr(ptr_add(stmt, 56))

    -- Allocate stack space for the variable
    let temp :: i64 = next_temp(cg)
    cg = inc_temp(cg)
    cg = emit_alloca(cg, temp, "i64")

    -- Add to symbol table
    cg = symtab_add(cg, name, temp)

    -- Check if there's an initializer at offset 152
    let init :: ptr<u8> = load_ptr(ptr_add(stmt, 152))
    let null_ptr :: ptr<u8> = 0
    if init != null_ptr do
        let init_kind :: i64 = load_i64(init)
        -- NODE_LITERAL_INT = 16 - use immediate store
        if init_kind == 16 do
            let val :: i64 = load_i64(ptr_add(init, 24))
            cg = emit_store_imm(cg, "i64", val, temp)
        else do
            -- General case: evaluate expression and store
            let init_res :: ExprResult = emit_expr_val(cg, init)
            cg = init_res.cg
            cg = emit_store(cg, "i64", init_res.temp, temp)
        end
    end
    ret cg
end

-- Check if a block ends with a return statement
fn block_ends_with_return(block :: ptr<u8>) -> bool do
    let null_ptr :: ptr<u8> = 0
    if block == null_ptr do
        ret false
    end
    let stmts_data :: ptr<u8> = load_ptr(ptr_add(block, 176))
    let stmts_count :: i64 = load_i64(ptr_add(block, 184))
    if stmts_count == 0 do
        ret false
    end
    -- Check last statement
    let last_idx :: i64 = stmts_count - 1
    let last_stmt :: ptr<u8> = load_ptr(ptr_add(stmts_data, last_idx * 8))
    let kind :: i64 = load_i64(last_stmt)
    -- NODE_RETURN = 9
    if kind == 9 do
        ret true
    end
    ret false
end

-- Emit block statements (helper for if/while bodies)
fn emit_block(cg :: Codegen, block :: ptr<u8>) -> Codegen do
    let null_ptr :: ptr<u8> = 0
    if block == null_ptr do
        ret cg
    end
    -- stmts.data at offset 176, stmts.count at offset 184
    let stmts_data :: ptr<u8> = load_ptr(ptr_add(block, 176))
    let stmts_count :: i64 = load_i64(ptr_add(block, 184))
    let i :: i64 = 0
    while i < stmts_count do
        let stmt :: ptr<u8> = load_ptr(ptr_add(stmts_data, i * 8))
        cg = emit_stmt(cg, stmt)
        i = i + 1
    end
    ret cg
end

-- Emit if statement
fn emit_if_stmt(cg :: Codegen, stmt :: ptr<u8>) -> Codegen do
    -- Get condition (offset 192), then_branch (offset 200), else_branch (offset 208)
    let condition :: ptr<u8> = load_ptr(ptr_add(stmt, 192))
    let then_branch :: ptr<u8> = load_ptr(ptr_add(stmt, 200))
    let else_branch :: ptr<u8> = load_ptr(ptr_add(stmt, 208))
    let null_ptr :: ptr<u8> = 0

    -- Emit condition and get result temp
    let cond_res :: ExprResult = emit_expr_val(cg, condition)
    cg = cond_res.cg
    let cond_temp :: i64 = cond_res.temp

    -- Allocate labels
    let then_label :: i64 = next_label(cg)
    cg = inc_label(cg)
    let else_label :: i64 = next_label(cg)
    cg = inc_label(cg)
    let end_label :: i64 = next_label(cg)
    cg = inc_label(cg)

    -- Emit conditional branch
    if else_branch == null_ptr do
        -- No else branch: br cond, then, end
        cg = emit_br_cond(cg, cond_temp, then_label, end_label)
    else do
        -- Has else branch: br cond, then, else
        cg = emit_br_cond(cg, cond_temp, then_label, else_label)
    end

    -- Emit then block
    cg = emit_label(cg, then_label)
    cg = emit_block(cg, then_branch)
    -- Only branch if block doesn't end with return
    if block_ends_with_return(then_branch) == false do
        cg = emit_br(cg, end_label)
    end

    -- Emit else block if present
    if else_branch != null_ptr do
        cg = emit_label(cg, else_label)
        cg = emit_block(cg, else_branch)
        -- Only branch if block doesn't end with return
        if block_ends_with_return(else_branch) == false do
            cg = emit_br(cg, end_label)
        end
    end

    -- Emit end label
    cg = emit_label(cg, end_label)

    ret cg
end

-- Emit while statement
fn emit_while_stmt(cg :: Codegen, stmt :: ptr<u8>) -> Codegen do
    -- Get condition (offset 192), body (offset 200 - stored in then_branch)
    let condition :: ptr<u8> = load_ptr(ptr_add(stmt, 192))
    let body :: ptr<u8> = load_ptr(ptr_add(stmt, 200))

    -- Allocate labels
    let loop_label :: i64 = next_label(cg)
    cg = inc_label(cg)
    let body_label :: i64 = next_label(cg)
    cg = inc_label(cg)
    let end_label :: i64 = next_label(cg)
    cg = inc_label(cg)

    -- Jump to loop header
    cg = emit_br(cg, loop_label)

    -- Loop header: evaluate condition
    cg = emit_label(cg, loop_label)
    let cond_res :: ExprResult = emit_expr_val(cg, condition)
    cg = cond_res.cg
    cg = emit_br_cond(cg, cond_res.temp, body_label, end_label)

    -- Body
    cg = emit_label(cg, body_label)
    cg = emit_block(cg, body)
    cg = emit_br(cg, loop_label)

    -- End
    cg = emit_label(cg, end_label)

    ret cg
end

-- Emit a single statement
fn emit_stmt(cg :: Codegen, stmt :: ptr<u8>) -> Codegen do
    let kind :: i64 = load_i64(stmt)
    -- NODE_VAR_DECL = 4
    if kind == 4 do
        cg = emit_var_decl(cg, stmt)
    end
    -- NODE_RETURN = 9
    if kind == 9 do
        -- init (return value) is at offset 152
        let ret_expr :: ptr<u8> = load_ptr(ptr_add(stmt, 152))
        let null_ptr :: ptr<u8> = 0
        if ret_expr == null_ptr do
            cg = emit_ret(cg, "i32", 0)
        else do
            let ret_kind :: i64 = load_i64(ret_expr)
            -- NODE_LITERAL_INT = 16 - use immediate return
            if ret_kind == 16 do
                let val :: i64 = load_i64(ptr_add(ret_expr, 24))
                cg = emit_ret(cg, "i32", val)
            else do
                -- General case: evaluate expression and return
                let ret_res :: ExprResult = emit_expr_val(cg, ret_expr)
                cg = ret_res.cg
                -- Truncate i64 to i32 for return value
                let trunc_temp :: i64 = next_temp(cg)
                cg = inc_temp(cg)
                cg = emit_trunc(cg, trunc_temp, "i64", "i32", ret_res.temp)
                cg = emit_ret_temp(cg, "i32", trunc_temp)
            end
        end
    end
    -- NODE_IF = 10
    if kind == 10 do
        cg = emit_if_stmt(cg, stmt)
    end
    -- NODE_WHILE = 11
    if kind == 11 do
        cg = emit_while_stmt(cg, stmt)
    end
    -- NODE_EXPR_STMT = 13
    if kind == 13 do
        -- Expression is at offset 72 (left field)
        let expr :: ptr<u8> = load_ptr(ptr_add(stmt, 72))
        cg = emit_expr(cg, expr)
    end
    ret cg
end

-- Emit function body statements
fn emit_body(cg :: Codegen, body :: ptr<u8>) -> Codegen do
    let null_ptr :: ptr<u8> = 0
    if body == null_ptr do
        cg = emit_ret(cg, "i32", 0)
        ret cg
    end
    -- stmts.data at offset 176, stmts.count at offset 184
    let stmts_data :: ptr<u8> = load_ptr(ptr_add(body, 176))
    let stmts_count :: i64 = load_i64(ptr_add(body, 184))
    let i :: i64 = 0
    while i < stmts_count do
        let stmt :: ptr<u8> = load_ptr(ptr_add(stmts_data, i * 8))
        cg = emit_stmt(cg, stmt)
        i = i + 1
    end
    ret cg
end

-- Emit parameter declarations at function start
fn emit_params(cg :: Codegen, params_data :: ptr<u8>, params_count :: i64) -> Codegen do
    let i :: i64 = 0
    while i < params_count do
        let param :: ptr<u8> = load_ptr(ptr_add(params_data, i * 8))
        let param_name :: ptr<u8> = load_ptr(ptr_add(param, 56))

        -- Allocate stack space for this parameter
        let temp :: i64 = next_temp(cg)
        cg = inc_temp(cg)
        cg = emit_alloca(cg, temp, "i64")

        -- Store parameter value into alloca
        cg = emit_store_param(cg, i, temp)

        -- Add to symbol table
        cg = symtab_add(cg, param_name, temp)

        i = i + 1
    end
    ret cg
end

-- Helper to emit a single function declaration
-- This workaround avoids the C compiler bug with load_ptr inside while loops
fn emit_fn_decl(cg :: Codegen, decl :: ptr<u8>) -> Codegen do
    -- Initialize symbol table for this function
    cg = symtab_init(cg)

    -- Get function name from node (offset 56)
    let name :: ptr<u8> = load_ptr(ptr_add(decl, 56))

    -- Get parameters (params.data at 128, params.count at 136)
    let fn_params_data :: ptr<u8> = load_ptr(ptr_add(decl, 128))
    let fn_params_count :: i64 = load_i64(ptr_add(decl, 136))

    -- Emit function start with parameters
    if fn_params_count > 0 do
        cg = emit_fn_start_params(cg, name, "i32", fn_params_count)
        -- Emit each parameter in signature
        let i :: i64 = 0
        while i < fn_params_count do
            let is_last :: bool = i == fn_params_count - 1
            cg = emit_fn_param(cg, i, is_last)
            i = i + 1
        end
        cg = emit_fn_params_end(cg)
        -- Emit parameter allocas and stores
        cg = emit_params(cg, fn_params_data, fn_params_count)
    else do
        cg = emit_fn_start(cg, name, "i32")
    end

    -- Get body (offset 120) and emit statements
    let body :: ptr<u8> = load_ptr(ptr_add(decl, 120))
    cg = emit_body(cg, body)
    cg = emit_fn_end(cg)
    ret cg
end

fn codegen_ast(cg :: Codegen, np :: ptr<u8>) -> Codegen do
    cg = emit_module_header(cg)

    let count :: i64 = load_i64(ptr_add(np, 168))
    let data :: ptr<u8> = load_ptr(ptr_add(np, 160))

    print("Decl count: ")
    print_int(count)
    println()

    -- Walk declarations and emit functions
    let i :: i64 = 0
    while i < count do
        let decl :: ptr<u8> = load_ptr(ptr_add(data, i * 8))
        cg = emit_fn_decl(cg, decl)
        i = i + 1
    end

    ret cg
end

fn do_codegen(ast :: ptr<u8>) -> i32 do
    print("Generating IR...")
    println()
    let cg :: Codegen = codegen_new()
    cg = codegen_ast(cg, ast)

    let ir_path :: ptr<u8> = "/tmp/claude/nullc_out.ll"
    let f :: ptr<u8> = file_open_write(ir_path)
    let out :: StringBuf = cg.output
    file_write(f, out.data, out.len)
    file_close(f)
    print("Written to ")
    print(ir_path)
    println()

    ret 0
end

fn do_parse(source :: ptr<u8>, size :: i64) -> ptr<u8> do
    print("Parsing...")
    println()

    let p :: Parser = parser_new(source, size)
    let result :: ParseResult = parse_program(p)
    p = result.p
    if p.had_error do
        print("Parse ERROR")
        println()
        let np :: ptr<u8> = 0
        ret np
    end
    print("Parse OK")
    println()

    ret result.node
end

fn main() -> i32 do
    print("=== nullc Compiler ===")
    println()

    let source :: ptr<u8> = file_read_all("examples/hello.null")
    let null_ptr :: ptr<u8> = 0
    if source == null_ptr do
        print("Failed to read")
        println()
        ret 1
    end

    let f :: ptr<u8> = file_open_read("examples/hello.null")
    let size :: i64 = file_size(f)
    file_close(f)
    print("Read ")
    print_int(size)
    print(" bytes")
    println()

    let ast :: ptr<u8> = do_parse(source, size)
    if ast == null_ptr do
        ret 1
    end

    let result :: i32 = do_codegen(ast)
    let zero :: i32 = 0
    if result != zero do
        ret result
    end

    print("=== Done ===")
    println()
    ret 0
end
