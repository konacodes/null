-- nullc/main.null
-- Self-hosted null compiler - minimal AST-driven version
-- Note: Uses hardcoded name "main" due to compiler bug with
-- loading names inside while loops

@use "std/io.null"
@use "std/mem.null"
@use "std/string.null"
@use "std/file.null"
@use "nullc/parser.null"
@use "nullc/codegen.null"

-- Get return value from a return statement
-- Returns the integer literal value (assumes simple case)
fn get_return_value(ret_node :: ptr<u8>) -> i64 do
    -- init (return value) is at offset 152
    let init :: ptr<u8> = load_ptr(ptr_add(ret_node, 152))
    let null_ptr :: ptr<u8> = 0
    if init == null_ptr do
        ret 0
    end
    -- Get int_value from the literal (offset 24)
    let val :: i64 = load_i64(ptr_add(init, 24))
    ret val
end

-- Get function name from a call expression
fn get_call_name(call_node :: ptr<u8>) -> ptr<u8> do
    -- callee is at offset 96, it should be an identifier node
    let callee :: ptr<u8> = load_ptr(ptr_add(call_node, 96))
    -- identifier name is at offset 56
    let name :: ptr<u8> = load_ptr(ptr_add(callee, 56))
    ret name
end

-- Check if a call has string literal argument
fn call_has_string_arg(call_node :: ptr<u8>) -> bool do
    -- args.data at offset 104, args.count at offset 112
    let args_count :: i64 = load_i64(ptr_add(call_node, 112))
    if args_count > 0 do
        let args_data :: ptr<u8> = load_ptr(ptr_add(call_node, 104))
        let first_arg :: ptr<u8> = load_ptr(args_data)
        let arg_kind :: i64 = load_i64(first_arg)
        -- NODE_LITERAL_STRING = 18
        if arg_kind == 18 do
            ret true
        end
    end
    ret false
end

-- Emit an expression (handles calls)
fn emit_expr(cg :: Codegen, expr :: ptr<u8>) -> Codegen do
    let kind :: i64 = load_i64(expr)
    -- NODE_CALL = 23
    if kind == 23 do
        let name :: ptr<u8> = get_call_name(expr)
        if call_has_string_arg(expr) do
            -- Map io_print to puts for now
            cg = emit_call_with_str(cg, "puts", 0)
        else do
            cg = emit_call_void(cg, name)
        end
    end
    ret cg
end

-- Emit a single statement
fn emit_stmt(cg :: Codegen, stmt :: ptr<u8>) -> Codegen do
    let kind :: i64 = load_i64(stmt)
    -- NODE_RETURN = 9
    if kind == 9 do
        let val :: i64 = get_return_value(stmt)
        cg = emit_ret(cg, "i32", val)
    end
    -- NODE_EXPR_STMT = 13
    if kind == 13 do
        -- Expression is at offset 72 (left field)
        let expr :: ptr<u8> = load_ptr(ptr_add(stmt, 72))
        cg = emit_expr(cg, expr)
    end
    ret cg
end

-- Emit function body statements
fn emit_body(cg :: Codegen, body :: ptr<u8>) -> Codegen do
    let null_ptr :: ptr<u8> = 0
    if body == null_ptr do
        cg = emit_ret(cg, "i32", 0)
        ret cg
    end
    -- stmts.data at offset 176, stmts.count at offset 184
    let stmts_data :: ptr<u8> = load_ptr(ptr_add(body, 176))
    let stmts_count :: i64 = load_i64(ptr_add(body, 184))
    let i :: i64 = 0
    while i < stmts_count do
        let stmt :: ptr<u8> = load_ptr(ptr_add(stmts_data, i * 8))
        cg = emit_stmt(cg, stmt)
        i = i + 1
    end
    ret cg
end

-- Helper to emit a single function declaration
-- This workaround avoids the C compiler bug with load_ptr inside while loops
fn emit_fn_decl(cg :: Codegen, decl :: ptr<u8>) -> Codegen do
    -- Get function name from node (offset 56)
    let name :: ptr<u8> = load_ptr(ptr_add(decl, 56))
    cg = emit_fn_start(cg, name, "i32")
    -- Get body (offset 120) and emit statements
    let body :: ptr<u8> = load_ptr(ptr_add(decl, 120))
    cg = emit_body(cg, body)
    cg = emit_fn_end(cg)
    ret cg
end

fn codegen_ast(cg :: Codegen, np :: ptr<u8>) -> Codegen do
    cg = emit_module_header(cg)

    let count :: i64 = load_i64(ptr_add(np, 168))
    let data :: ptr<u8> = load_ptr(ptr_add(np, 160))

    print("Decl count: ")
    print_int(count)
    println()

    -- Walk declarations and emit functions
    let i :: i64 = 0
    while i < count do
        let decl :: ptr<u8> = load_ptr(ptr_add(data, i * 8))
        cg = emit_fn_decl(cg, decl)
        i = i + 1
    end

    ret cg
end

fn do_codegen(ast :: ptr<u8>) -> i32 do
    print("Generating IR...")
    println()
    let cg :: Codegen = codegen_new()
    cg = codegen_ast(cg, ast)

    let ir_path :: ptr<u8> = "/tmp/claude/nullc_out.ll"
    let f :: ptr<u8> = file_open_write(ir_path)
    let out :: StringBuf = cg.output
    file_write(f, out.data, out.len)
    file_close(f)
    print("Written to ")
    print(ir_path)
    println()

    ret 0
end

fn do_parse(source :: ptr<u8>, size :: i64) -> ptr<u8> do
    print("Parsing...")
    println()

    let p :: Parser = parser_new(source, size)
    let result :: ParseResult = parse_program(p)
    p = result.p
    if p.had_error do
        print("Parse ERROR")
        println()
        let np :: ptr<u8> = 0
        ret np
    end
    print("Parse OK")
    println()

    ret result.node
end

fn main() -> i32 do
    print("=== nullc Compiler ===")
    println()

    let source :: ptr<u8> = file_read_all("examples/hello.null")
    let null_ptr :: ptr<u8> = 0
    if source == null_ptr do
        print("Failed to read")
        println()
        ret 1
    end

    let f :: ptr<u8> = file_open_read("examples/hello.null")
    let size :: i64 = file_size(f)
    file_close(f)
    print("Read ")
    print_int(size)
    print(" bytes")
    println()

    let ast :: ptr<u8> = do_parse(source, size)
    if ast == null_ptr do
        ret 1
    end

    let result :: i32 = do_codegen(ast)
    let zero :: i32 = 0
    if result != zero do
        ret result
    end

    print("=== Done ===")
    println()
    ret 0
end
