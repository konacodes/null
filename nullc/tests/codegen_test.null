-- nullc/tests/codegen_test.null
-- Basic tests for codegen functionality (tests underlying operations)

@use "std/io.null"
@use "std/mem.null"
@use "std/string.null"
@use "std/file.null"

-- Test string buffer allocation (used by codegen output)
fn test_string_buffer() -> bool do
    let size :: u64 = 1024
    let buf :: ptr<u8> = alloc(size)
    let null_ptr :: ptr<u8> = 0

    if buf == null_ptr do
        ret false
    end

    -- Write some content
    let h :: u8 = 72   -- 'H'
    let i :: u8 = 105  -- 'i'
    let z :: u8 = 0    -- null terminator
    buf[0] = h
    buf[1] = i
    buf[2] = z

    -- Verify content
    let c :: u8 = buf[0]
    if c != h do
        dealloc(buf)
        ret false
    end

    dealloc(buf)
    ret true
end

-- Test integer to string conversion patterns (used for temp names)
fn test_int_digits() -> bool do
    -- Test basic digit extraction
    let num :: i64 = 42
    let d0 :: i64 = num % 10      -- should be 2
    let d1 :: i64 = (num / 10) % 10  -- should be 4

    if d0 != 2 do
        ret false
    end
    if d1 != 4 do
        ret false
    end
    ret true
end

-- Test file operations (used for writing IR)
fn test_file_ops() -> bool do
    let path :: ptr<u8> = "/tmp/claude/codegen_test_output.txt"
    let f :: ptr<u8> = file_open_write(path)
    let null_ptr :: ptr<u8> = 0

    if f == null_ptr do
        ret false
    end

    -- Write test content
    let content :: ptr<u8> = "test output"
    let len :: u64 = 11
    let written :: u64 = file_write(f, content, len)
    file_close(f)

    if written != len do
        ret false
    end

    -- Read it back
    let f2 :: ptr<u8> = file_open_read(path)
    if f2 == null_ptr do
        ret false
    end

    let buf :: ptr<u8> = alloc(64)
    let read_count :: u64 = file_read(f2, buf, 64)
    file_close(f2)

    -- Verify content
    let ok :: bool = read_count >= len
    dealloc(buf)

    ret ok
end

-- Test counter increments (used for temp/label counters)
fn test_counters() -> bool do
    mut counter :: i64 = 0

    let v0 :: i64 = counter
    counter = counter + 1
    let v1 :: i64 = counter
    counter = counter + 1
    let v2 :: i64 = counter

    if v0 != 0 do
        ret false
    end
    if v1 != 1 do
        ret false
    end
    if v2 != 2 do
        ret false
    end
    ret true
end

-- Test string concatenation pattern (used for IR emission)
fn test_str_concat_pattern() -> bool do
    -- Test building up IR-like strings
    let part1 :: ptr<u8> = "define "
    let part2 :: ptr<u8> = "i32 "
    let part3 :: ptr<u8> = "@main"

    -- Verify each part
    if str_len(part1) != 7 do
        ret false
    end
    if str_len(part2) != 4 do
        ret false
    end
    if str_len(part3) != 5 do
        ret false
    end

    ret true
end

fn main() -> i32 do
    io_print("=== Codegen Tests ===")

    mut passed :: i64 = 0
    mut failed :: i64 = 0

    if test_string_buffer() do
        io_print("test_string_buffer: PASS")
        passed = passed + 1
    else do
        io_print("test_string_buffer: FAIL")
        failed = failed + 1
    end

    if test_int_digits() do
        io_print("test_int_digits: PASS")
        passed = passed + 1
    else do
        io_print("test_int_digits: FAIL")
        failed = failed + 1
    end

    if test_file_ops() do
        io_print("test_file_ops: PASS")
        passed = passed + 1
    else do
        io_print("test_file_ops: FAIL")
        failed = failed + 1
    end

    if test_counters() do
        io_print("test_counters: PASS")
        passed = passed + 1
    else do
        io_print("test_counters: FAIL")
        failed = failed + 1
    end

    if test_str_concat_pattern() do
        io_print("test_str_concat_pattern: PASS")
        passed = passed + 1
    else do
        io_print("test_str_concat_pattern: FAIL")
        failed = failed + 1
    end

    io_print("=== Codegen Tests Complete ===")
    if failed == 0 do
        ret 0
    end
    ret 1
end
