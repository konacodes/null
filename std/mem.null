-- std/mem.null
-- Memory management operations for null

@extern "C" do
    fn malloc(size :: u64) -> ptr<u8>
    fn calloc(count :: u64, size :: u64) -> ptr<u8>
    fn realloc(p :: ptr<u8>, size :: u64) -> ptr<u8>
    fn free(p :: ptr<u8>) -> void
    fn memcpy(dest :: ptr<u8>, src :: ptr<u8>, n :: u64) -> ptr<u8>
    fn memset(s :: ptr<u8>, c :: i32, n :: u64) -> ptr<u8>
    fn memmove(dest :: ptr<u8>, src :: ptr<u8>, n :: u64) -> ptr<u8>
end

-- Allocate memory (returns null on failure)
fn alloc(size :: u64) -> ptr<u8> do
    ret malloc(size)
end

-- Allocate and zero memory
fn alloc_zeroed(size :: u64) -> ptr<u8> do
    ret calloc(1, size)
end

-- Allocate array of count elements of given size
fn alloc_array(count :: u64, elem_size :: u64) -> ptr<u8> do
    ret calloc(count, elem_size)
end

-- Reallocate memory to new size
fn mem_realloc(p :: ptr<u8>, new_size :: u64) -> ptr<u8> do
    ret realloc(p, new_size)
end

-- Free allocated memory
fn dealloc(p :: ptr<u8>) -> void do
    free(p)
end

-- Copy memory from src to dest (non-overlapping)
fn mem_copy(dest :: ptr<u8>, src :: ptr<u8>, n :: u64) -> ptr<u8> do
    ret memcpy(dest, src, n)
end

-- Move memory (handles overlapping regions)
fn mem_move(dest :: ptr<u8>, src :: ptr<u8>, n :: u64) -> ptr<u8> do
    ret memmove(dest, src, n)
end

-- Set memory to a value
fn mem_set(s :: ptr<u8>, c :: i32, n :: u64) -> ptr<u8> do
    ret memset(s, c, n)
end

-- Zero memory
fn mem_zero(s :: ptr<u8>, n :: u64) -> ptr<u8> do
    let zero :: i32 = 0
    ret memset(s, zero, n)
end

-- Pointer arithmetic: add offset to pointer
fn ptr_add(p :: ptr<u8>, offset :: i64) -> ptr<u8> do
    let addr :: i64 = p
    let new_addr :: i64 = addr + offset
    let result :: ptr<u8> = new_addr
    ret result
end

-- Store a 64-bit integer at memory location using byte-by-byte writes
fn store_i64(dest :: ptr<u8>, val :: i64) -> void do
    let b0 :: u8 = val
    let b1 :: u8 = val >> 8
    let b2 :: u8 = val >> 16
    let b3 :: u8 = val >> 24
    let b4 :: u8 = val >> 32
    let b5 :: u8 = val >> 40
    let b6 :: u8 = val >> 48
    let b7 :: u8 = val >> 56
    dest[0] = b0
    dest[1] = b1
    dest[2] = b2
    dest[3] = b3
    dest[4] = b4
    dest[5] = b5
    dest[6] = b6
    dest[7] = b7
end

-- Load a 64-bit integer from memory location
fn load_i64(src :: ptr<u8>) -> i64 do
    let b0 :: i64 = src[0]
    let b1 :: i64 = src[1]
    let b2 :: i64 = src[2]
    let b3 :: i64 = src[3]
    let b4 :: i64 = src[4]
    let b5 :: i64 = src[5]
    let b6 :: i64 = src[6]
    let b7 :: i64 = src[7]
    let result :: i64 = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24) | (b4 << 32) | (b5 << 40) | (b6 << 48) | (b7 << 56)
    ret result
end

-- Store a pointer at memory location (pointers are 8 bytes on 64-bit)
fn store_ptr(dest :: ptr<u8>, val :: ptr<u8>) -> void do
    let v :: i64 = val
    store_i64(dest, v)
end

-- Load a pointer from memory location
fn load_ptr(src :: ptr<u8>) -> ptr<u8> do
    let v :: i64 = load_i64(src)
    let result :: ptr<u8> = v
    ret result
end
